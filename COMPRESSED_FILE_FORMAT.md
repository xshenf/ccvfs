# CCVFS 压缩文件格式说明

## 1. 概述

CCVFS (Compress Crypt VFS) 是一个 SQLite 的虚拟文件系统扩展，支持对数据库文件进行透明的压缩和加密。本文档详细介绍了压缩后文件的内部结构以及读取压缩数据库的原理。

## 2. 压缩文件结构

### 2.1 整体布局

压缩后的数据库文件采用分块存储结构，每个数据块独立进行压缩和加密处理：

```
+------------------+------------------+------------------+-----+------------------+
| 数据块 0         | 数据块 1         | 数据块 2         | ... | 数据块 n         |
+------------------+------------------+------------------+-----+------------------+
```

### 2.2 数据块结构

每个数据块由头部和数据部分组成：

```
+------------------+------------------+------------------+------------------+
| 块头部 (16B)     | 压缩数据长度(4B) | 原始数据长度(4B) | 压缩加密数据     |
+------------------+------------------+------------------+------------------+
```

#### 2.2.1 块头部 (16字节)

块头部包含以下字段：

| 字段名       | 大小 | 说明                         |
|-------------|------|------------------------------|
| Magic       | 4B   | 魔数标识，用于识别文件格式    |
| BlockNumber | 4B   | 块序列号，用于定位数据块      |
| Checksum    | 4B   | 校验和，用于验证数据完整性    |
| Flags       | 4B   | 标志位，指示压缩/加密状态等   |

#### 2.2.2 长度字段

- 压缩数据长度 (4字节)：压缩后数据的字节长度
- 原始数据长度 (4字节)：压缩前数据的字节长度

#### 2.2.3 数据部分

数据部分包含经过压缩和加密处理的实际数据。

### 2.3 数据组织方式

1. **固定块大小**：默认块大小为 8KB，可通过编译时宏定义调整
2. **独立处理**：每个数据块独立进行压缩和加密，互不影响
3. **顺序存储**：数据块按照逻辑顺序连续存储在文件中

## 3. 读取压缩数据库的原理

### 3.1 基本流程

读取压缩数据库的过程包括以下步骤：

```
1. 计算逻辑偏移量对应的块号和块内偏移量
2. 定位到物理文件中的对应数据块
3. 读取整个数据块到内存缓冲区
4. 验证数据完整性（检查校验和）
5. 解密数据（如果启用加密）
6. 解压缩数据（如果启用压缩）
7. 从解压后的数据中提取所需部分
8. 返回给调用者
```

### 3.2 详细步骤说明

#### 3.2.1 偏移量计算

当 SQLite 请求读取从逻辑偏移量 `offset` 开始的 `length` 字节数据时：

1. 计算起始块号：`start_block = offset / CCVFS_DEFAULT_BLOCK_SIZE`
2. 计算结束块号：`end_block = (offset + length - 1) / CCVFS_DEFAULT_BLOCK_SIZE`
3. 计算在起始块内的偏移量：`inner_offset = offset % CCVFS_DEFAULT_BLOCK_SIZE`

#### 3.2.2 数据块定位

1. 根据块号计算物理文件中的位置
2. 考虑到压缩后数据大小可能不同，需要建立逻辑到物理位置的映射

#### 3.2.3 数据读取与验证

1. 读取完整的数据块到缓冲区
2. 检查 Magic 字段验证文件格式
3. 验证校验和确保数据完整性
4. 检查 Flags 字段确定是否需要解密/解压缩

#### 3.2.4 解密处理

如果 Flags 指示数据已加密：

1. 使用注册的解密算法进行解密
2. 解密过程可能需要用户提供密钥

#### 3.2.5 解压缩处理

如果 Flags 指示数据已压缩：

1. 读取压缩数据长度和原始数据长度
2. 使用注册的解压缩算法进行解压缩

#### 3.2.6 数据提取

1. 从解压后的数据中提取所需的字节范围
2. 处理跨块读取的情况
3. 将提取的数据返回给 SQLite

### 3.3 缓存机制

为了提高性能，CCVFS 实现了缓存机制：

1. **块缓存**：缓存最近访问的数据块，避免重复读取和处理
2. **解压数据缓存**：缓存解压后的明文数据
3. **LRU 策略**：使用最近最少使用策略管理缓存

## 4. 写入压缩数据库的原理

### 4.1 基本流程

写入压缩数据库的过程包括以下步骤：

```
1. 接收待写入的明文数据
2. 将数据分割成适当大小的块
3. 对每个数据块进行压缩（如果启用压缩）
4. 对压缩后的数据进行加密（如果启用加密）
5. 构造数据块结构
6. 写入到物理文件中的适当位置
7. 更新元数据和索引信息
```

### 4.2 特殊情况处理

1. **部分块写入**：当写入操作不完整覆盖一个数据块时，需要先读取现有数据，合并后再处理
2. **块分裂与合并**：处理插入和删除操作可能导致的数据块分裂与合并
3. **空间管理**：有效管理文件中的空闲空间，避免文件过度膨胀

## 5. 错误处理与恢复

### 5.1 错误检测

1. **校验和验证**：检测数据是否损坏
2. **魔数验证**：确认文件格式正确
3. **长度验证**：检查数据长度是否合理

### 5.2 错误恢复

1. **块级隔离**：单个块损坏不影响其他块的访问
2. **损坏报告**：向用户报告损坏的块信息
3. **备份恢复**：支持从备份恢复数据

## 6. 性能优化策略

### 6.1 读取优化

1. **预读机制**：预测性地读取可能需要的数据块
2. **并行处理**：对独立的数据块进行并行处理
3. **智能缓存**：根据访问模式优化缓存策略

### 6.2 写入优化

1. **批量写入**：合并多个小写入操作
2. **延迟处理**：延迟压缩和加密操作直到必要时
3. **异步IO**：使用异步IO提高写入性能

## 7. 安全性设计

### 7.1 数据加密

1. **强加密算法**：支持多种工业标准加密算法
2. **密钥管理**：提供安全的密钥管理机制
3. **防篡改设计**：检测并拒绝处理被篡改的数据

### 7.2 数据完整性

1. **校验和保护**：防止数据意外损坏
2. **版本控制**：支持文件格式版本管理
3. **安全删除**：支持安全删除敏感数据

## 8. 兼容性考虑

### 8.1 SQLite 兼容性

1. **API 兼容**：完全兼容 SQLite 原生 API
2. **功能兼容**：支持 SQLite 的大部分功能特性
3. **性能兼容**：尽量减少对 SQLite 性能的影响

### 8.2 平台兼容性

1. **跨平台支持**：支持 Windows、Linux、macOS 等主流平台
2. **编译器兼容**：支持多种 C 编译器
3. **依赖库兼容**：最小化外部依赖

## 9. 限制与约束

### 9.1 技术限制

1. **WAL 模式**：可能不完全支持 WAL 模式下的某些特性
2. **在线备份**：在线备份功能可能受限
3. **性能开销**：压缩和加密会带来一定的 CPU 和内存开销

### 9.2 使用约束

1. **密钥管理**：用户需要妥善保管加密密钥
2. **算法选择**：压缩效果和性能取决于选择的算法
3. **文件共享**：压缩加密的数据库文件不能直接被普通 SQLite 工具读取

---